/* tape_set.c: 'set' functions for libspectrum_tape_block
   Copyright (c) 2003 Philip Kendall

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 49 Temple Place, Suite 330, Boston, MA 02111-1307 USA

   Author contact information:

   E-mail: pak21-fuse@srcf.ucam.org
   Postal address: 15 Crescent Road, Wokingham, Berks, RG40 2DB, England

*/

/* NB: this file is autogenerated from tape_accessors.txt by tape_set.pl */

#include <config.h>

#include "internals.h"
#include "tape_block.h"

libspectrum_error
libspectrum_tape_block_set_bit_length( libspectrum_tape_block *block, libspectrum_dword bit_length )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_RAW_DATA: block->types.raw_data.bit_length = bit_length; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_bit_length",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_bit0_length( libspectrum_tape_block *block, libspectrum_dword bit0_length )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_PURE_DATA: block->types.pure_data.bit0_length = bit0_length; break;
    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.bit0_length = bit0_length; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_bit0_length",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_bit1_length( libspectrum_tape_block *block, libspectrum_dword bit1_length )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_PURE_DATA: block->types.pure_data.bit1_length = bit1_length; break;
    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.bit1_length = bit1_length; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_bit1_length",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_bits_in_last_byte( libspectrum_tape_block *block, size_t bits_in_last_byte )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_PURE_DATA: block->types.pure_data.bits_in_last_byte = bits_in_last_byte; break;
    case LIBSPECTRUM_TAPE_BLOCK_RAW_DATA: block->types.raw_data.bits_in_last_byte = bits_in_last_byte; break;
    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.bits_in_last_byte = bits_in_last_byte; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_bits_in_last_byte",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_count( libspectrum_tape_block *block, size_t count )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_PURE_TONE: block->types.pure_tone.pulses = count; break;
    case LIBSPECTRUM_TAPE_BLOCK_PULSES: block->types.pulses.count = count; break;
    case LIBSPECTRUM_TAPE_BLOCK_LOOP_START: block->types.loop_start.count = count; break;
    case LIBSPECTRUM_TAPE_BLOCK_SELECT: block->types.select.count = count; break;
    case LIBSPECTRUM_TAPE_BLOCK_ARCHIVE_INFO: block->types.archive_info.count = count; break;
    case LIBSPECTRUM_TAPE_BLOCK_HARDWARE: block->types.hardware.count = count; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_count",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_data( libspectrum_tape_block *block, libspectrum_byte* data )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_CUSTOM: block->types.custom.data = data; break;
    case LIBSPECTRUM_TAPE_BLOCK_PURE_DATA: block->types.pure_data.data = data; break;
    case LIBSPECTRUM_TAPE_BLOCK_RAW_DATA: block->types.raw_data.data = data; break;
    case LIBSPECTRUM_TAPE_BLOCK_ROM: block->types.rom.data = data; break;
    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.data = data; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_data",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_data_length( libspectrum_tape_block *block, size_t data_length )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_CUSTOM: block->types.custom.length = data_length; break;
    case LIBSPECTRUM_TAPE_BLOCK_PURE_DATA: block->types.pure_data.length = data_length; break;
    case LIBSPECTRUM_TAPE_BLOCK_RAW_DATA: block->types.raw_data.length = data_length; break;
    case LIBSPECTRUM_TAPE_BLOCK_ROM: block->types.rom.length = data_length; break;
    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.length = data_length; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_data_length",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_ids( libspectrum_tape_block *block, int *ids )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_ARCHIVE_INFO: block->types.archive_info.ids = ids; break;
    case LIBSPECTRUM_TAPE_BLOCK_HARDWARE: block->types.hardware.ids = ids; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_ids",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_offset( libspectrum_tape_block *block, int offset )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_JUMP: block->types.jump.offset = offset; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_offset",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_offsets( libspectrum_tape_block *block, int *offsets )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_SELECT: block->types.select.offsets = offsets; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_offsets",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_pause( libspectrum_tape_block *block, libspectrum_dword pause )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_MESSAGE: block->types.message.time = pause; break;
    case LIBSPECTRUM_TAPE_BLOCK_PAUSE: block->types.pause.length = pause; break;
    case LIBSPECTRUM_TAPE_BLOCK_PURE_DATA: block->types.pure_data.pause = pause; break;
    case LIBSPECTRUM_TAPE_BLOCK_RAW_DATA: block->types.raw_data.pause = pause; break;
    case LIBSPECTRUM_TAPE_BLOCK_ROM: block->types.rom.pause = pause; break;
    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.pause = pause; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_pause",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_pilot_length( libspectrum_tape_block *block, libspectrum_dword pilot_length )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.pilot_length = pilot_length; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_pilot_length",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_pilot_pulses( libspectrum_tape_block *block, size_t pilot_pulses )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.pilot_pulses = pilot_pulses; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_pilot_pulses",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_pulse_length( libspectrum_tape_block *block, libspectrum_dword pulse_length )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_PURE_TONE: block->types.pure_tone.length = pulse_length; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_pulse_length",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_pulse_lengths( libspectrum_tape_block *block, libspectrum_dword *pulse_lengths )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_PULSES: block->types.pulses.lengths = pulse_lengths; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_pulse_lengths",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_state( libspectrum_tape_block *block, libspectrum_tape_state_type state )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_PURE_DATA: block->types.pure_data.state = state; break;
    case LIBSPECTRUM_TAPE_BLOCK_RAW_DATA: block->types.raw_data.state = state; break;
    case LIBSPECTRUM_TAPE_BLOCK_ROM: block->types.rom.state = state; break;
    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.state = state; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_state",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_sync1_length( libspectrum_tape_block *block, libspectrum_dword sync1_length )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.sync1_length = sync1_length; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_sync1_length",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_sync2_length( libspectrum_tape_block *block, libspectrum_dword sync2_length )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_TURBO: block->types.turbo.sync2_length = sync2_length; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_sync2_length",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_text( libspectrum_tape_block *block, libspectrum_byte* text )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_GROUP_START: block->types.group_start.name = text; break;
    case LIBSPECTRUM_TAPE_BLOCK_COMMENT: block->types.comment.text = text; break;
    case LIBSPECTRUM_TAPE_BLOCK_MESSAGE: block->types.message.text = text; break;
    case LIBSPECTRUM_TAPE_BLOCK_CUSTOM: block->types.custom.description = text; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_text",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_texts( libspectrum_tape_block *block, libspectrum_byte* *texts )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_ARCHIVE_INFO: block->types.archive_info.strings = texts; break;
    case LIBSPECTRUM_TAPE_BLOCK_SELECT: block->types.select.descriptions = texts; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_texts",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_types( libspectrum_tape_block *block, int *types )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_HARDWARE: block->types.hardware.types = types; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_types",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

libspectrum_error
libspectrum_tape_block_set_values( libspectrum_tape_block *block, int *values )
{
  switch( block->type ) {

    case LIBSPECTRUM_TAPE_BLOCK_HARDWARE: block->types.hardware.values = values; break;

    default:
      libspectrum_print_error(
        LIBSPECTRUM_ERROR_INVALID,
        "invalid block type %d given to libspectrum_tape_block_values",
        block->type
      );
      return LIBSPECTRUM_ERROR_INVALID;
  }

  return LIBSPECTRUM_ERROR_NONE;
}

